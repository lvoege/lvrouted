<?xml version="1.0" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4CR2//EN"
		      "http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd" [
<!ENTITY wleiden "<ulink url='http://www.wirelessleiden.nl/'>WirelessLeiden</ulink>">
<!ENTITY freebsd "<ulink url='http://www.freebsd.org/'>FreeBSD</ulink>">
<!ENTITY svn "<ulink url='http://subversion.tigris.org/'>Subversion</ulink>">
<!ENTITY ocaml "<ulink url='http://www.ocaml.org/'>O'Caml</ulink>">
]>
<article>
  <artheader>
    <title>lvrouted</title>
    <author>
      <firstname>Lodewijk</firstname>
      <surname>V&ouml;ge</surname>
      <affiliation>
        <orgname>WirelessLeiden</orgname>
      </affiliation>
      <email>lodewijk@wirelessleiden.nl</email>
    </author>
  </artheader>
  <para>
    This is a very simple shortest path routing daemon. It was written to
    replace ospfd in the &wleiden; network. Sometimes assumptions are made
    about the network that hold for &wleiden;, but may not for other
    networks. Those cases are marked and, if possible, alternative
    implementations provided.
  </para>
  <para>
    System requirements are &freebsd; 5.0 or 5.3. Other versions may work, but
    haven't been tested at all. A port to other systems would be fairly easy
    in that all unportable code is isolated in one relatively small source
    file.
  </para>
  <para>
    The main body of code is written in &ocaml;. For changes other than
    porting the bit of C code that handles interaction with the kernel, you
    would need to know &ocaml; (something I would highly recommend).
  </para>
  <section>
    <title>Features</title>
    <itemizedlist>
      <listitem>
        <para>
	  UDP based. No firmware-confusing multi- or broadcasts.
	</para>
      </listitem>
      <listitem>
        <para>
	  No per-node configuration.
	</para>
      </listitem>
      <listitem>
        <para>
	  Uses spanning trees, so no count-to-infinity.
	</para>
      </listitem>
      <listitem>
        <para>
	  Specific wireless hacks to speed up convergence and route
	  propagation.
	</para>
      </listitem>
      <listitem>
        <para>
	  Protection against malicious packets and replaying of legitimate
	  packets.
	</para>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Auto-configuration</title>
    <para>
      If your network has both a well-defined routable range <footnote>
        <para>
	  For &wleiden;, this is 172.16.0.0/12.
	</para>
      </footnote> and well-defined interlink netmasks (say, anything narrower
      than a /29), the daemon will be able to do the right thing
      automatically.
    </para>
    <para>
      Relevant tunables are <varname>Common.min_routable</varname>,
      <varname>Common.max_routable</varname> and
      <varname>Common.interlink_netmask</varname>.
    </para>
    <warning>
      <para>
        Do not set <varname>Common.interlink_netmask</varname> too wide. The
        daemon will consider all addresses in the interlink subnet other than
        its own possible neighbors. It will allocate resources for them and
        spend time trying to reach its peers on those addresses. Keep your
        interlinks as narrow as possible.
      </para>
    </warning>
  </section>
  <section>
    <title>Spanning trees</title>
    <para>
      This branch uses spanning trees to achieve shortest-path routing without
      cycles. A node knows its local addresses and will receive the spanning
      trees of its neighbors. It can then merge these pieces of information
      into a spanning tree for the node plus a routing table by simply
      traversing the trees breadth-first. The new spanning tree is sent to
      the neighbors and the route table is uploaded to the kernel.
    </para>
    <para>
      Note that while "spanning tree" and "network" may conjure up images of a
      single spanning tree for the network that leaves many links unused, this
      is not the case here. Every node has a spanning tree of its own, and
      they will all be different.
    </para>
  </section>
  <section>
    <title>Wireless hacks</title>
    <para>
      The daemon tries to know quickly if a client has lost (or gained)
      association or association has been lost (gained) with a master. Media
      state and arp tables are monitored to figure out what neighbors
      became (un)reachable, rather than waiting for the relatively long
      neighbor timeout<footnote>
        <para>
	  The haven't-heard-from-X-for-so-long-it-must-be-dead timeout.
	</para>
      </footnote>to occur.
    </para>
    <para>
      When such events are detected, a new spanning tree and new route table
      are produced immediately and sent around.
    </para>
  </section>
  <section>
    <title>Security</title>
    <para>
      A &wleiden; assumption is that machines can trust eachother, that
      administrative connections to those machines are trusted (ssh). Users
      can not be trusted, since it's an open network. Attackers may try to get
      the daemon to crash, or try to muck up routing in the network by feeding
      nodes faulty or old data<footnote>
       <para>
	 A patch is ready to be deployed to hide interlink SSIDs. This will
	 make it more difficult for an attacker, but certainly not impossible
	 as most of the node configurations live in a publically accessible
	 &svn; repository.
       </para>
      </footnote>.
    </para>
    <para>
      Because nodes can trust eachother and administrative connections are
      assumed secure, a simple secret key scheme should put the bar for an
      attacker significantly higher.
    </para>
    <para>
      A packet consists of a hash, a sequence number and the serialized
      spanning tree. The hash is SHA1 of the concatenation of the secret key,
      the sequence number and the serialized tree. An attacker won't know the
      secret key and will not be able to produce a valid hash.
    </para>
    <para>
      The sequence number is an increasing number. A node will keep track of
      the sequence numbers it receives from its neighbors, and will only
      accept packets with a higher sequence number. Currently, the sequence
      number is simply the unix timestamp. The sequence number is part of the
      hash, so an attacked cannot change it without invalidating the hash.
      This solves replay attacks with (once) legitimate packets.
    </para>
    <para>
      A node will initialize the structures for its neighbors with the lowest
      possible timestamp. This leaves a hole where an attacker can replay
      old packets. This hole closes once the real neighbor sends its first
      packet and the node updates the timestamp in the neighbor structure to
      beyond what the attacker can have captured. So be it, that's a hole
      small enough for me not to care.
    </para>
    <warning>
      <para>
        This does pose a problem with machines that cannot keep time in their
        CMOSs, like many old donated machines. If you have such machines,
        either do not correct their time at all, or start the routing daemon
        <emphasis>after</emphasis> correcting their time (like with
        <application>ntpdate</application>). 
      </para>
      <para>
        If you first start the routing daemon and then correct the time, the
        following will happen. Unix timestamps are 32bit unsigned integers,
        while &ocaml; integers are 31bit signed. The current Unix timestamp is
        large enough to wrap around into a a large
        <emphasis>negative</emphasis> &ocaml; integer. Clocks that cannot keep
        time are usually initialized to 1980, which is not large enough to
        wrap around, so that is a large positive &ocaml; integer. If the
        daemon manages to get a packet out before the time correction, its
        neighbors will remember that timestamp. After the time correction,
        packets will have the very large negative sequence number and will be
        rejected. The node will be ignored by its neighbors for over twenty
        years. You'd have to restart the daemon on all neighbors to fix this.
      </para>
    </warning>
  </section>
  <section>
    <title>Tree marshaling</title>
    <para>
      Marshalling trees was done using &ocaml;'s generic
      <varname>Marshal</varname> module at first. This is completely network
      agnostic (even data structure agnostic, it will serialize any data
      structure you pass it) and took just over eight bytes per tree node.
    </para>
    <para>
      Recently, custom marshaling code was added. This assumes the
      172.16.0.0/12 range. For other ranges, either the original code must be
      used by setting the <varname>Common.use_own_marshaller</varname> to
      false, or the marshaling code must be adapted.
    </para>
    <para>
      The idea behind the custom marshaller is that to store a node, it is
      enough to store the node contents (the address in this case) and the
      number of children. Now, a part of the address will be fixed (the first
      twelve bits for &wleiden;) and can be used to store the number of
      children. That gives four bytes per tree node, versus just over eight
      for the generic &ocaml; marshaller.<footnote>
        <para>
          Three bytes per tree node was almost possible, but that would leave
          four bits for the number of children. &wleiden; either already has
          nodes with more than sixteen ranges or will conceivably get them
          eventually.
        </para>
      </footnote>
    </para>
    <para>
      The code that would need adapting for other ranges is in
      <function>tree_to_string_rec()</function> and
      <function>string_to_tree_rec()</function> in
      <filename>lowlevel_c.c</filename>. As this involves navigating &ocaml;
      data structures, you may want to read the manual on interfacing with C.
    </para>
  </section>
</article>
